grammar Decaf;

/* Parser grammar */
program: CLASS PROGRAM BRACKET_OPEN field_decl_s method_decl_s BRACKET_CLOSE;

field_decl_s: (field_decl)*;
field_decl: TYPE field_decl_name (COMMA field_decl_name)*;
field_decl_name: (id | id SQUARE_BRACKET_OPEN int_literal SQUARE_BRACKET_CLOSE);

method_decl_s: (method_decl)*;
method_decl: (TYPE | VOID) id PARENTHESIS_OPEN param_decl_s PARENTHESIS_CLOSE block;
param_decl_s: (param_decl)*; 
param_decl: (TYPE id) (COMMA TYPE id)*;

block: BRACKET_OPEN var_decl_s statement_s BRACKET_CLOSE;
var_decl_s: (var_decl)*;
var_decl: TYPE id  (COMMA id)*;
statement_s: (statement)*;
statement: location ASSIGN_OP expr 
			| method_call
			| IF PARENTHESIS_OPEN expr PARENTHESIS_CLOSE  block (ELSE block)*
			| FOR id '=' expr COMMA expr block
			| RETURN (expr)*
			| BREAK
			| CONTINUE
			| block;
			
			
id: ;
int_literal:;



/*Lexer grammar */
CLASS: 'class';
PROGRAM: 'Program';

BRACKET_OPEN: '{';
BRACKET_CLOSE: '}';

TYPE: 'int' | 'boolean';
VOID: 'void';

SQUARE_BRACKET_OPEN: '[';
SQUARE_BRACKET_CLOSE: ']';
COMMA: ',';

PARENTHESIS_OPEN: '(';
PARENTHESIS_CLOSE: ')';

ASSIGN_OP: '=' | '+=' | '-=';
IF: 'if';
ELSE: 'else';
FOR: 'for';
RETURN: 'return';
BREAK: 'break';
CONTINUE: 'continue';