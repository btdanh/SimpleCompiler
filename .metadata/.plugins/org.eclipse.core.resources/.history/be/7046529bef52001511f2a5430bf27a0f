grammar Decaf;

@lexer::header{
	import java.util.Map;
	import java.util.HashMap;
}

tokens{CLASS, PROGRAM, IF, ELSE, FOR, RETURN, BREAK, CONTINUE, CALLOUT, BOOLEAN, TRUE, FALSE, INT, VOID}

@lexer::members{
	
	public static final int SHOULD_SHOW = 100;
	
	Map<String, Integer> keywords = new HashMap<String, Integer>(){{
		put("class", DecafParser.CLASS);
		put("Program", DecafParser.PROGRAM);
		put("if", DecafParser.IF);
		put("else", DecafParser.ELSE);
		put("for", DecafParser.FOR);
		put("return", DecafParser.RETURN);
		put("break", DecafParser.BREAK);
		put("continue", DecafParser.CONTINUE);
		put("callout", DecafParser.CALLOUT);
		put("boolean", DecafParser.BOOLEAN);
		put("true", DecafParser.TRUE);
		put("false", DecafParser.FALSE);
		put("int", DecafParser.INT);
		put("void", DecafParser.VOID);		
	}};
}

/* Parser grammar */
program: CLASS PROGRAM BRACKET_OPEN field_decl_s method_decl_s BRACKET_CLOSE;

field_decl_s: (field_decl)* SEMICOLON;
field_decl: type field_decl_name (COMMA field_decl_name)*;
field_decl_name: (IDENTIIER | IDENTIIER SQUARE_BRACKET_OPEN INT_LITERAL SQUARE_BRACKET_CLOSE);

method_decl_s: (method_decl)*;
method_decl: (type | VOID) IDENTIIER PARENTHESIS_OPEN param_decl_s PARENTHESIS_CLOSE block;
param_decl_s: (param_decl)*; 
param_decl: (type IDENTIIER) (COMMA type IDENTIIER)*;

block: BRACKET_OPEN var_decl_s statement_s BRACKET_CLOSE;
var_decl_s: (var_decl)* SEMICOLON;
var_decl: type IDENTIIER  (COMMA IDENTIIER)*;
statement_s: (statement)*;
statement: location ASSIGN_OP expr SEMICOLON
			| method_call SEMICOLON
			| IF PARENTHESIS_OPEN expr PARENTHESIS_CLOSE  block (ELSE block)*
			| FOR IDENTIIER '=' expr COMMA expr block
			| RETURN (expr)* SEMICOLON
			| BREAK SEMICOLON
			| CONTINUE SEMICOLON
			| block ;
			
			
method_call: method_name PARENTHESIS_OPEN (expr (COMMA expr)*)* PARENTHESIS_CLOSE
			| CALLOUT PARENTHESIS_OPEN STRING_LITERAL (COMMA callout_arg (COMMA callout_arg)*)* PARENTHESIS_CLOSE;
method_name: IDENTIIER;

location: IDENTIIER 
		| IDENTIIER SQUARE_BRACKET_OPEN expr SQUARE_BRACKET_CLOSE;
		
expr: location
	| method_call
	| literal
	| expr bin_op expr
	| '-' expr
	| '!' expr
	| PARENTHESIS_OPEN expr PARENTHESIS_CLOSE; 

callout_arg: expr | STRING_LITERAL;
bin_op: ARITH_OP | RELOP | EQ_OP | COND_OP;
literal: INT_LITERAL | CHAR_LITERAL | BOOL_LITERAL;

fragment DECIMAL_LITERAL: (DIGIT)+ ;
fragment HEX_LITERAL: HEX_PRFEFIX (HEX_DIGIT)+;
HEX_PRFEFIX: '0x';
INT_LITERAL:(DECIMAL_LITERAL | HEX_LITERAL)->channel(SHOULD_SHOW);
CHAR_LITERAL: ('\'' CHAR '\'')->channel(SHOULD_SHOW);
STRING_LITERAL: ('"' (CHAR)* '"')->channel(SHOULD_SHOW);
BOOL_LITERAL: ('true' | 'false')->channel(SHOULD_SHOW);

fragment ID: ALPHA (ALPHA_NUM)*;  
IDENTIIER: (ID { 
	if(keywords.containsKey(getText())){
		setType(keywords.get(getText()));
	}
	else{
		_channel = SHOULD_SHOW;
	}
});
fragment ALPHA_NUM: ALPHA | DIGIT;
fragment HEX_DIGIT: DIGIT | ('a' .. 'f') | ('A' .. 'F');


/*Lexer grammar */

BRACKET_OPEN: '{';
BRACKET_CLOSE: '}';

type: INT | BOOLEAN;


SQUARE_BRACKET_OPEN: '[';
SQUARE_BRACKET_CLOSE: ']';
COMMA: ',';
SEMICOLON: ';';

PARENTHESIS_OPEN: '(';
PARENTHESIS_CLOSE: ')';

ASSIGN_OP: '=' | '+=' | '-=';
ARITH_OP: '+' | '-' | '*' | '/' | '%';
RELOP: '<' | '>' | '<=' | '>=';
EQ_OP: '==' | '!=';
COND_OP: '&&' | '||';

fragment ALPHA: ('a' .. 'z') | ('A' .. 'Z') | '_';
fragment DIGIT: ('0' .. '9');
fragment CHAR: (' ' .. '~') | '\"' | '\\' | '\'' | '\n' | '\t';

WHITESPACE : ( '\t' | ' ' | '\r' | '\n'| '\u000C' )+ ->skip;
BLOCK_COMMENT : '/*' .*? '*/' -> skip;
EOL_COMMENT : '//' .*? '\n' -> skip;


 

